IP分片包是**怎么被插入相应的组装链表的**。这里用一个直观的图形来解释这一过程。

 ![](分片.assets/20210115195355866.png)

  图中展示了有两个数据包正在被组装的过程，两个`ip_reassdata`结构分别用于两个数据包的组装过程。第一个数据包已经组装好了两个分片数据，第二个组装好了一个分片数据。LWIP并不像标准协议中描述的那样，另外分配一个[数据结构](https://so.csdn.net/so/search?q=数据结构&spm=1001.2101.3001.7020)来描述各个分片数据，而是直接利用各个分片数据，**将数据中IP头部的前八个字节拿来存储组装过程中的相关信息**，因此每个进来的IP分片数据包头都被改变了，也因此要使用`ip_reassdata`结构中的`iphdr`字段来暂时保存IP数据包的完整头部。

  这八个字节被变成了什么值呢，这就是结构体`ip_reass_helper`的内容了。**这个结构体就是组装过程中最为重要的结构体**了。看看，这恐怕是最简单的一个结构体了。

```c
struct ip_reass_helper {
	struct pbuf *next_pbuf;
	u16_t start;
	u16_t end;
};
12345
```

  **`next_pbuf`字段在组装过程中用来连接各个分片数据包**；**`start`字段用来记录该分片数据包数据在整个IP包中的起始位置**；同理，**`end`字段表示在IP包中的结束位置。**

  **函数`ip_reass_chain_frag_into_datagram_and_validate`用来向一个`ip_reassdata`结构中插入一个IP分片包`pbuf`，插入后检查该IP包是否被组装完毕，未组装完毕则返回0，否则返回非0值**。很明显，这个函数的**输入参数有两个，`ip_reassdata`结构和分片包`pbuf`**。下面仔细看看这个函数名最长的函数到底干了些什么工作。

  **首先**它会**从该IP分片包的头部中提取信息**，包括分片数据的**起始偏移地址`offset`和分片数据的长度`len`**，之后它**将该IP分片包的头部得 字节强制转换为`ip_reass_helper`结构**，并**将`start`字段的值置为`offset`；`end`字段的值置为`offset+len`**；**`next_pbuf`字段的值置为NULL**。到这里，进来的这个分片包已经被改变面貌了，它的IP头部已经被毁坏，下面就会将这个改头换面的分片包进行插入操作了。**插入操作主要是利用比较各个`ip_reass_helper`的`start`和`end`字段的值以确定这个分片包被插在链表中的哪个位置**，插入位置的寻找是整个组装过程中最难理解的部分了，但从原理上看是很简单的一个过程，这里不再对查找插入位置及插入操作的源码做解析。

  到这步，**分片的数据包已经被插入到相应的`ip_reassdata`结构后的链表中了**，此时这个函数名最长的函数要**检查是否这个`ip_reassdata`对应的数据包已经组装完毕**。这里要**分两步**来看，**第一**是**判断该数据包的最后一个分片包是否已经到来**，在上面一节中已经讲过，当收到的IP分片包为某个IP包的最后一个分片时，函数`ip_reass`会把对应`ip_reassdata`结构的`flags`字段置`1`，所以，**如果检测到某个`ip_reassdata`结构的`flags`字段仍为`0`，说明最后一个分片还未被收到，IP数据包组装肯定还未完成，此时，函数名最长的函数直接返回0即可**。**第二**步，**如果发现`flags`字段置`1`，说明最后一个分片包已经收到，但是整个IP是否被组装完毕还是未知**，因为在网络上，分片包不是每次都能按次序到达，因此，收到的最后一个分片数据包不一定是最后一个分片包。此时**需要遍历`ip_reassdata`结构后面的各个分片包链表，以检测是否还有分片包未被接收到**。

  **到这步，`ip_reass_chain_frag_into_datagram_and_validate`函数就完成工作了，它将分片的数据插入了某个`ip_reassdata`结构的数据分片链表，并检测该IP数据包是否被组装完毕**，组装完毕则返回一个非0值，否则返回0值。

  这里，我们有回到了`ip_reass`函数，`ip_reass`通过函数调用将某个分片数据包插入相应的个`ip_reassdata`结构后，通过函数的返回值来决定要做的下一步操作。如果数据包组装未完成，`ip_reass`函数需要向调用它的函数返回一个空指针，如果数据包组装完成，它就要向调用它的函数返回这个组装好的数据包。从上面的图中可以看出，被组装好的数据包是全部分片被挂接在一个`ip_reassdata`结构上的，**`ip_reass`函数需要从这个`ip_reassdata`结构上取下相应的各个分片数据，并删除各个分片中的不必要信息，然后将整个数据包返回给调用者**。为了完成这个任务，`ip_reass`函数进行了下面的工作。

  **先**将`ip_reassdata`结构中的`iphdr`字段各个值做相应的修正，如修正报文总长度、校验和，**然后**将`iphdr`字段全部拷贝到第一个分片包的IP头部字段中，**这样**整个IP数据包的头部就出现在第一个分片信息包中了，**接下来**从第二个分片包开始，将它们的IP头部信息删除，**这样**，一个完整的IP数据包就重新组装好了。**最后**，调用`ip_reass_dequeue_datagram`函数删除数据包组装过程中使用的`ip_reassdata`结构体，即从上图所述的`reassdatagrams`[链表](https://so.csdn.net/so/search?q=链表&spm=1001.2101.3001.7020)删除对应`reassdata`的节点。

  这个圈子绕得有点大，本来是在讲`ip_input`函数的，结果就讲到了`ip_reass`函数，后来又讲到了`ip_reass_chain_frag_into_datagram_and_validate`函数。没办法，谁让后面两个函数是为`ip_input`函数服务的呢！`ip_input`函数使用`ip_reass`组装好的数据包递交到上层TCP或UDP等应用中去，在前面已经讲过了。

  现在我们还是要回到原路上，走上`ip_input`这条道路。`ip_input`的基本流程已经在前面讲得很清楚了，**还有一个函数为它服务，即`ip_forward`函数**，它**主要是完成数据包的转发工作**，当设备接收到的数据包不是给自己的时候，它就可以选择将该数据包转发出去，本来这里没有必要讲`ip_forward`函数的，因为在一般的应用中，这项功能会被禁止，**设备收到不是给自己的数据包时，将在`ip_input`函数处理的初期被丢弃**。但到目前，我们还未涉及到任何关于IP数据包发送的内容，考虑了很久，还是觉得应该把`ip_forward`函数讲解一下，因为数据包的转发与数据包的发送是完全一样的原理，使用了完全相同的接口函数，因此**讲解了`ip_forward`函数就等于讲解了IP层数据包发送的所有工作细节**。在TCP层或UDP层必然涉及到数据包的发送工作，在这里就利用`ip_forward`函数将IP层数据包发送的整个过程讲解清楚，这样逻辑清楚，利于理解！

  当**收到一个IP数据包后**，LWIP会**遍历所有网络接口的IP地址**，判断这个数据包是不是给自己的，**如果不是**，就要调用收到该数据包的那个网络接口将数据包转发出去。**转发前**还要**检测这个包是不是一个广播包**，**如果是**，**直接丢弃**，不做处理。现在来看看数据包转发函数ip_forward做了哪些工作呢，这个**函数的输入参数有三个**：**要转发的数据包指针**，**要转发的数据包的IP报头指针**，**收到该数据包的的网络接口数据结构netif指针**。

  **首先**，调用`ip_route`函数找到转发该数据包应该使用的网络接口，`ip_route`函数以数据包IP报头中的目标地址为参数，查找应该使用的相关结构。如果找不到满足要求的接口，则选择缺省网络接口。`ip_route`函数现在这里打住，在讲完`ip_forward`函数之后，再对它进行详细的讲解。

  `ip_forward`检查`ip_route`函数找到的网络接口是否为有效，所谓有效，即不能为空，也不能为接收到该IP包的那个接口。当判定网络接口为无效时，数据包不会被转发。当可以用某个网络接口转发数据包时，**`ip_forward`先将该IP报头中`TTL`字段值减`1`，若`TTL`变为`0`，则需要向源主机发送一份超时`ICMP`信息，表示当前数据包的生存周期到了，这个数据包在这里被丢弃，不会被转发出去**。至于怎样发送这个超时的`ICMP`信息包，这就涉及到IP层数据包的发送函数`ip_output`了，我们将在后面慢慢道来。

  接下来**函数重新计算头部校验和**，因为头部`TTL`字段的值已经被修改，**最后调用`netif`结构注册的`output`函数，该函数将数据包组装成以太网数据帧并发送出去。**前面说过了，这个函数就是`etharp_output`。

  到这里`ip_forward`函数的工作就完成了，还剩下两个问题，**`ip_route`函数和怎样发送一个超时的`ICMP`信息包出去**。这里讲解第一个问题，第二个问题放在`ICMP`部分。**`ip_route`函数以目标IP地址为输入参数，然后在网络接口结构链表`netif_list`上找寻与该IP地址在同一子网上的网络接口，若找到则返回满足要求的网络接口，若找不到则返回缺省网络接口。**





这里要被调到用的函数叫 tcp_parseopt，它目前
仅能够做的是提取选项中的 MSS（最长报文大小）字段，在 LWIP 以后的更高版本中，该
函数将被扩充，以支持更多的 TCP 选项。此后，函数还可以调用 tcp_eff_send_mss 来设置控
制块中 mss 字段的值，该函数可直译为“有效发送最长报文大小”，所谓有效，就是指收到
SYN 数据包中的 MSS 值不能大于我的硬件支持的最大发送报文长度，即硬件的 MTU。因
此当收到的 MSS 值更大时，设置控制块中 mss 字段值会被设置为 MTU，而不是 MSS。  



```c
 pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
```





